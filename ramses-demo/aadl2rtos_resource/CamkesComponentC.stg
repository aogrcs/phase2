import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
// Some design notes: 
//   TBD 
//      
//   
// 
//
//
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>


/////////////////////////////////////////////////////////////////////
//
// Functions for managing RPCs
//
/////////////////////////////////////////////////////////////////////

writeAadlArgument(parameter) ::= 
<< <if(parameter.isInput)><parameter.type.camkesInputToAadlInput><endif><parameter.name> >>

writeProvidesEndpointRpc(rpc, endpoint) ::= << 
<writeCamkesCRpcPrototype(rpc, endpoint)>
{
	<endpoint.aadlName>_<rpc.name>(<rpc.parameters:writeAadlArgument();separator=", ">);
}
>>


writeProvidesEndpoint(endpoint) ::= <<
<if(!endpoint.isExternal)><\\>
<endpoint.remoteProcedureGroup.remoteProcedures:writeProvidesEndpointRpc(endpoint); separator="\n">
<endif>
>>


writeCamkesArgument(parameter) ::= 
<< <if(parameter.isInput)><parameter.type.aadlInputToCamkesInput><endif><parameter.name> >>

writeRequiresEndpointRpc(rpc, endpoint) ::= << 
<writeAadlCRpcPrototype(rpc, endpoint)>
{
	<endpoint.name>_<rpc.name>(<rpc.parameters:writeCamkesArgument();separator=", ">);
}
>>

writeRequiresEndpoint(endpoint) ::= << 
<if(!endpoint.isExternal)><\\>
<endpoint.remoteProcedureGroup.remoteProcedures:writeRequiresEndpointRpc(endpoint); separator="\n">
<endif>
>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event data ports, 
// used for active thread to active thread communications.
//
// TODO: writer and reader functions have different format...why?
//
/////////////////////////////////////////////////////////////////////

LocalPortWriterName(port) ::= <<
<port.name>_<port.type.writerFn>
>>

ReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueFrontName>] = <port.name> ;
<else><aadlInputToValMemcpy(port.type, {<port.queueDataName>[<port.queueFrontName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToAadlOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

InputEventDataPortDecls(port) ::= <<

<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.type.aadlOutputType.name> <port.name>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.type.aadlInputType.name> <port.name>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

bool <LocalPortWriterName(port)>(<port.type.camkesInputType.name> arg) {
	bool result;
	<port.camkesMutexLockFnCall>; 
	result = <port.queueWriteName>(<port.type.camkesInputToAadlInput> arg);
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return result;
}


bool <port.aadlReaderFnName>(<port.type.aadlOutputType.name> arg) {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	result = <port.queueReadName>(arg);
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues for event ports, 
// used for active thread to active thread communications.
//
// TODO: writer and reader functions have different format...why?
//
/////////////////////////////////////////////////////////////////////

InputEventPortDecls(port) ::= <<
<port.indexType.name> <port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

bool <LocalPortWriterName(port)> {
	<port.camkesMutexLockFnCall>; 
	// Note: possibility for overflow here - should I worry about MAXINT messages?
	<port.index>++;
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return true;
}

bool <port.aadlReaderFnName>() {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	if (<port.index> > 0) {
		<port.index>--;
		result = true;
	} else {
		result = false;
	}
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>

optInputEventDataPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || 
    !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event data port <port.name>
//
//////////////////////////////////////////////////////

<InputEventDataPortDecls(port)>
<endif>
>>


optInputEventPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event port <port.name>
//
//////////////////////////////////////////////////////

<InputEventPortDecls(port)>
<endif>
>>


///////////////////////////////////////////////////////////////////////////
//
// Functions for managing Read/Write interfaces between active threads.
//
///////////////////////////////////////////////////////////////////////////

optConstCamkesInputArg(port) ::= "<if(port.hasData)><port.type.camkesInputType.name> <port.name><endif>"

componentRemoteWriteFunction(port) ::= <<

// The writer function is called remotely through RPC, so follows the 
// RPC naming and return convention.  
bool <LocalPortWriterName(port)>(<optConstCamkesInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<if(port.type.isBaseType)><port.readerWriterImplVar> = <port.name>;
	<else><camkesInputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
	<endif>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.aadlReaderFnName>(<userSendOptAadlOutputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<if(port.type.isBaseType)><port.type.aadlOutputToVal><port.name> = <port.readerWriterImplVar>;
	<else><valToAadlOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
	<endif>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentRemoteWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
bool <port.aadlWriterFnName>(<port.type.aadlInputType.name> <port.name>) {
	<LocalPortWriterName(port)>(<port.type.aadlInputToCamkesInput> <port.name>);
	return true;
}

>>


/////////////////////////////////////////////////////////////////////
//
// Code for dispatching active threads based on external 
// stimulus to its dispatcher fn.
//
/////////////////////////////////////////////////////////////////////

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (<dispatcher.inputEventDispatcherPort.aadlReaderFnName>()) {
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.valToAadlOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.type.valToAadlInput><dispatcher.inputEventDispatcherPort.name>); 
}

>>

/////////////////////////////////////////////////////////////////////
//
// UserEntrypointCaller functions
// 
// These functions provide the "scaffolding" functions necessary to 
// set up the output event ports prior to making a call to the user
// code.
// 
// These are the implementations of the RPC functions for passive 
// components that are called using CAmkES.  They are also used 
// in active components to set up local procedure calls to user code.
//
/////////////////////////////////////////////////////////////////////


userEntrypointCallerCall(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
<externalHandler.handlerName>(<dispatcher.type.camkesInputToAadlInput><dispatcher.name>); 
<else><externalHandler.handlerName>();
<endif>
>>


userEntrypointCallerInputArg(dispatcher) ::=  << <dispatcher.type.camkesInputType.name> <dispatcher.name> >>


userEntrypointCallerDataOutputArg(dispatchContract) ::= 
<< <if(dispatchContract.canDispatch)> <if(dispatchContract.port.hasData)><dispatchContract.dispatchStructTypeName> *<dispatchContract.port.data>, <endif><\\> 
  <dispatchContract.port.indexType.aadlOutputType.name> <dispatchContract.port.index> <endif>
>>

userEntrypointCallerFnName(dispatcher) ::=
	"<dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName>"

userEntrypointCallerFnArgs(dispatcher) ::= <<
<if(dispatcher.hasData)>
<[userEntrypointCallerInputArg(dispatcher), dispatcher.dispatchableContracts:userEntrypointCallerDataOutputArg()]; separator=",\n">
<else>
<dispatcher.dispatchableContracts:userEntrypointCallerDataOutputArg();separator=",\n">
<endif>
>>

userEntrypointCallerAssignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<if(dispatchContract.canDispatch)><\\>
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = <dispatchContract.port.data>->f;<endif> 
*<dispatchContract.port.globalIndex> = 0; 
<endif>
>> 

userEntrypointCallerFn(dispatcher) ::= << 
void <userEntrypointCallerFnName(dispatcher)>(<userEntrypointCallerFnArgs(dispatcher)>) {
	<dispatcher.maxDispatchContracts.contracts:userEntrypointCallerAssignGlobals()>
	<dispatcher.externalHandlers:userEntrypointCallerCall(dispatcher)>
}	


>>	 


/////////////////////////////////////////////////////////////////////
//
// localSendDecl: 
// 
// This creates a local call to the queuing function 
/////////////////////////////////////////////////////////////////////

localSendDecl(connection) ::= <<
<if(connection.sourcePort.hasData)>
void <connection.sourcePort.qualifiedName>_<connection.destPort.type.writerFn>(<connection.sourcePort.type.camkesInputType.name> arg) {
	<LocalPortWriterName(connection.destPort)>(arg);
}
<else>
void <connection.sourcePort.qualifiedName>_<connection.destPort.type.writerFn>() {
	<LocalPortWriterName(connection.destPort)>();
}

<endif>

>>

/////////////////////////////////////////////////////////////////////
//
// userSendDefinition: 
// 
// These declarations construct the callback functions for user code
// in order to 'send' a message to other components.  In truth, they
// queue the message to be sent in local data; the actual 'send' is
// performed on the queued messages after the user code completes. 
//
/////////////////////////////////////////////////////////////////////

userSendCopyAadlInputToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = <port.name>;
<else><aadlInputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

userSendOptConstAadlInputArg(port) ::= "<if(port.hasData)><port.type.aadlInputType.name> <port.name><endif>"
userSendOptAadlOutputArg(port) ::= "<if(port.hasData)><port.type.aadlOutputType.name> <port.name><endif>"

userSendDefinition(port) ::= << 
bool <port.aadlWriterFnName>(<port:userSendOptConstAadlInputArg()>) {
	if (<port.globalMaxDispatchSize> > 0 && 
		 *<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><userSendCopyAadlInputToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
/////////////////////////////////////////////////////////////////////
//
// aadlDispatcher declarations
//
// These declarations are used to construct the AADL event loop 
// dispatcher for an AADL 'send' primitive.  They take as input the 
// input to be 'sent'.  They define the queues to be used 
// for any resulting messages to be transmitted based on the 
// user code's response to the message.  To interface with the user 
// code, they call the userEntrypointCaller function matching the 
// 'send' interface.  Then they drain the queues of generated 
// messages, calling an aadlDispatcher function for each message, 
// which will repeat the process for the next 'send'...
//
/////////////////////////////////////////////////////////////////////


aadlDispatcherDeclareData(dispatcherContract) ::= <<
<if(dispatcherContract.port.hasData)><dispatcherContract.dataDecl>;<endif>
<dispatcherContract.port.indexType.name> <dispatcherContract.port.index>;

>>

aadlDispatcherPassiveCallOutPortArg(port) ::= <<
<if(port.hasData)>		<port.type.valToAadlOutput><port.data>,<endif>
		<port.type.valToAadlOutput><port.index> >>

aadlDispatcherWritePassiveArg(port) ::= <<
<if(port.hasData)><port.type.valToAadlInput>(<port.data>.f[smaccm_it])<endif>
>>

aadlDispatcherWriteActiveArg(port) ::= <<
<if(port.hasData)><port.type.valToCamkesInput>(<port.data>.f[smaccm_it])<endif>
>>

aadlDispatcherPassiveCallOutArg(dispatchContract) ::= "<aadlDispatcherPassiveCallOutPortArg(dispatchContract.port)>"

aadlDispatcherCallPassiveTarget(portDest,portSrc) ::= <<
<portDest.dispatcher.dispatcherCFileDispatcherFnName>(<aadlDispatcherWritePassiveArg(portSrc)>);	
>>

aadlDispatcherCallActiveTarget(portDest,portSrc) ::= <<
<portSrc.qualifiedName>_<portDest.type.writerFn>(<aadlDispatcherWriteActiveArg(portSrc)>);	

>>

aadlDispatcherSendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index> && smaccm_it \< <dispatchContract.maxDispatchSize>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:aadlDispatcherCallPassiveTarget(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:aadlDispatcherCallActiveTarget(dispatchContract.port)>
}

>>


// TODO: is this function wrong?  I think it should always be the 
// passiveComponentDispatcherPathName...

aadlDispatcherFunctionName(dispatcher) ::= <<
<if(dispatcher.threadImplementation.isPassive)><\\>
<dispatcher.passiveComponentDispatcherPathName><\\>
<else><userEntrypointCallerFnName(dispatcher)><endif>
>>

 
aadlDispatcherFunctionArgs(dispatcher) ::= 
<< <if(dispatcher.hasData)><\\>
	 <[{ <dispatcher.type.aadlInputToCamkesInput> <dispatcher.name>}, dispatcher.dispatchableContracts:aadlDispatcherPassiveCallOutArg() ];separator=", \n"> 
	 <else><\\>
	<dispatcher.dispatchableContracts:aadlDispatcherPassiveCallOutArg();separator=", \n"> <endif>
>>

aadlDispatcherFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<if(dispatcher.hasData)><dispatcher.type.aadlInputType.name> <dispatcher.name><endif>) {
	<dispatcher.dispatchableContracts:aadlDispatcherDeclareData()>
	
	// make the call: 
	<aadlDispatcherFunctionName(dispatcher)>(<aadlDispatcherFunctionArgs(dispatcher)>	
		); 

<if(dispatcher.dispatchableContracts)>
	// call the aadl dispatchers for any generated output events.
	// to prevent misuse by malicious clients, we ensure that the number 
	// of dispatches is less than the maximum allowed dispatch count.
	uint32_t smaccm_it; 
	<dispatcher.dispatchableContracts:aadlDispatcherSendLoop(dispatcher)>
<endif>
}

>>

aadlDispatcherFunctionPrototype(dispatcher) ::=  <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<if(dispatcher.hasData)><dispatcher.type.aadlInputType.name> <dispatcher.name><endif>); 

>>

///////////////////////////////////////////////////////////////////////////
//
// Periodic and IRQ dispatcher functions
//
///////////////////////////////////////////////////////////////////////////

camkesRPCDispatchName(dispatcher) ::= <<
  <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>
>>

dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

bool <camkesRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.camkesInputType.name> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
	return true;
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <camkesRPCDispatchName(dispatcher)>() {
	<dispatcher.firstLevelInterruptHandler>();
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
	<dispatcher.name>_reg_callback(<camkesRPCDispatchName(dispatcher)>, NULL); 
}

>> 

///////////////////////////////////////////////////////////////////////////
//
// declarations related to main function
//
///////////////////////////////////////////////////////////////////////////


drainDispatcher(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>


dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>

portInitializer(port) ::= <<
<if(port.hasInitializeEntrypoint)><port.initializeEntrypointOpt.handlerName>();
<endif>
>>

registerIRQs(dispatcher) ::= << <if(dispatcher.isIRQ)><dispatcher.name>_reg_callback(<camkesRPCDispatchName(dispatcher)>, NULL);
<endif> >>

dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// port initialization routines (if any)... 
	<threadImpl.portList:portInitializer()>
	
	// thread initialization routines (if any)...
	<if(threadImpl.hasInitializeEntrypoint)><threadImpl.initializeEntrypointOpt.handlerName>();<endif>

	// register interrupt handlers (if any)...
	<threadImpl.dispatchers:registerIRQs()>
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatcher()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


///////////////////////////////////////////////////////////////////////////
//
// Variable declarations for dispatch ports.
//
///////////////////////////////////////////////////////////////////////////


portDispatchVarDeclarations(port) ::= <<
<if(port.hasData)><port.type.aadlOutputType.name> <port.globalData>; <endif>
<port.indexType.aadlOutputType.name> <port.globalIndex>;
<port.indexType.name> <port.globalMaxDispatchSize>; 	

>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<if(threadImpl.isActive)><\\>
///////////////////////////////////////////////////////////////////////////
//
// Local prototypes for AADL dispatchers
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.passiveDispatcherRegion:aadlDispatcherFunctionPrototype()> 
<endif>

///////////////////////////////////////////////////////////////////////////
//
// Functions for managed RPCs
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.requiredEndpoints:writeRequiresEndpoint()>

<threadImpl.providedEndpoints:writeProvidesEndpoint()>

///////////////////////////////////////////////////////////////////////////
//
// Functions and declarations for queued inputs
//
///////////////////////////////////////////////////////////////////////////

<threadImpl.inputEventDataPortList:optInputEventDataPortDecls()>
<threadImpl.inputEventPortList:optInputEventPortDecls()>

<threadImpl.allOutputEventPorts:portDispatchVarDeclarations()>

///////////////////////////////////////////////////////////////////////////
//
// Functions for dispatching IRQs, Local Send, and Periodic Events
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.dispatchers:dispatcherComponentEventDecls()>
<threadImpl.dispatchers:userEntrypointCallerFn()>
<threadImpl.allOutputEventPorts:userSendDefinition()>
<threadImpl.inputDataPortList:componentLocalReaderDecl()>
<threadImpl.outputDataPortList:componentRemoteWriterDecl()>
<threadImpl.localActiveThreadConnectionFrontier:localSendDecl()>

<if(threadImpl.isActive)><\\>
// Writing dispatchers...
<threadImpl.passiveDispatcherRegion:aadlDispatcherFunction()> 
<if(threadImpl.isExternal)><\\>
////////////////////////////////////////////////////////////////////////////
//
// NOTE: External thread, so we assume the run function is externally declared.
//
////////////////////////////////////////////////////////////////////////////
<else>
// thread main function
<dispatcherComponentMainFunction(threadImpl)>
<endif>
<endif>

>>

