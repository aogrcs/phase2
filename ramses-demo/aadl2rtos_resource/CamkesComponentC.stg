import "Common.stg"

////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

componentGlueCodeCFilePurpose(name) ::= <<
This C file contains the implementations of the AADL primitives
used by user-level declarations for thread <name>.   

The user code runs in terms of "dispatchers", which cause 
dispatch user-level handlers to execute.  These handlers can 
communicate using the standard AADL primitives, which are mapped
to C functions.

The send/receive handlers are not thread safe; it is assumed that 
this is handled by the CAmkES sequentialized access to the dispatch
handler.  There is only one dispatch interface for the component
containing all of the dispatch points.

The read/write handlers are thread safe because the writer comes 
through a dispatch interface but the reader is "local" on a dispatch
interface and so contention may occur.

>>

componentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, componentGlueCodeCFilePurpose(name))>"

componentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

/////////////////////////////////////////////////////////////////////
//
// Functions for managing send/receive queues.
//
/////////////////////////////////////////////////////////////////////

ReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueFrontName>] = <port.name> ;
<else><inputToValMemcpy(port.type, {<port.queueDataName>[<port.queueFrontName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

InputEventDataPortDecls(port) ::= <<

<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.nameAsOutputParam>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.nameAsInputParam>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

bool <port.name>_<port.type.writerFn>(<port.type.inputTypeName> arg) {
	bool result;
	<port.camkesMutexLockFnCall>; 
	result = <port.queueWriteName>(arg);
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return result;
}


bool <port.aadlReaderFnName>(<port.type.outputTypeName> arg) {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	result = <port.queueReadName>(arg);
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>


InputEventPortDecls(port) ::= <<
<port.indexType.name> <port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

bool <port.name>_<port.type.writerFn>() {
	<port.camkesMutexLockFnCall>; 
	// Note: possibility for overflow here - should I worry about MAXINT messages?
	<port.index>++;
	<port.camkesMutexUnlockFnCall>;
	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
	return true;
}

bool <port.aadlReaderFnName>() {
	bool result; 
	<port.camkesMutexLockFnCall>; 
	if (<port.index> > 0) {
		<port.index>--;
		result = true;
	} else {
		result = false;
	}
	<port.camkesMutexUnlockFnCall>;
	return result;
}

>>

optInputEventDataPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || 
    !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event data port <port.name>
//
//////////////////////////////////////////////////////

<InputEventDataPortDecls(port)>
<endif>
>>


optInputEventPortDecls(port) ::= <<
<if(port.threadImplementation.isActive || !port.hasDispatcher)>

//////////////////////////////////////////////////////
//
// Global data for event port <port.name>
//
//////////////////////////////////////////////////////

<InputEventPortDecls(port)>
<endif>
>>


///////////////////////////////////////////////////////////////////////////
//
// Functions for managing Read/Write interfaces
//
///////////////////////////////////////////////////////////////////////////

componentLocalWriteFunction(port) ::= <<

// The writer function is called remotely through RPC, so follows the 
// RPC naming and return convention.  
bool <port.name>_<port.type.writerFn>(<optConstInputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyToImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>

componentLocalReadFunction(port) ::= <<
bool <port.aadlReaderFnName>(<optOutputArg(port)>) {
	<port.camkesMutexLockFnCall>; 
	<copyFromImplVarStmt(port)>
	<port.camkesMutexUnlockFnCall>;
	return true;
}

>>


componentLocalReaderDecl(port) ::= <<
<port.readerWriterImplVarDecl>;

<componentLocalReadFunction(port)>
<componentLocalWriteFunction(port)>
>>

componentRemoteWriterDecl(port) ::= <<
bool <port.aadlWriterFnName>(<port.nameAsInputParam>) {
	<port.name>_<port.type.writerFn>(<port.name>);
	return true;
}

>>


/////////////////////////////////////////////////////////////////////
//
// Functions for dispatching active threads.
//
/////////////////////////////////////////////////////////////////////

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (<dispatcher.inputEventDispatcherPort.aadlReaderFnName>()) {
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.inputToOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.inputEventDispatcherPort.name>); 
}

>>

cPortTempVarDeclarations(port) ::= <<
<if(port.hasData)><port.globalDataParam>; <endif>
<port.globalIndexParam>;
<port.globalMaxDispatchSizeParam>; 	

>>

optDispatcherInputArg(dispatcher) ::= << <if(dispatcher.hasData)><dispatcher.nameAsInputParam> <endif> >>

cUserDispatcher(externalHandler, dispatcher) ::= <<
<if(dispatcher.hasData)>
<externalHandler.handlerName>(<dispatcher.name>); 
<else><externalHandler.handlerName>();
<endif>
>>


cPortOutputArg(dispatchContract) ::= << <if(dispatchContract.port.hasData)><dispatchContract.dispatchArrayTypeName> *<dispatchContract.port.data>, 
<endif> >>

cDispatchContractOutputArg(dispatchContract) ::= <<  <cPortOutputArg(dispatchContract)> <dispatchContract.port.indexParam> >>

componentCamkesDispatcherFnName(dispatcher) ::=
	"<dispatcher.threadImplementation.componentDispatcherInterfaceVarIdName>_<dispatcher.idlDispatcherName>"

componentCamkesDispatcherFnArgs(dispatcher) ::= <<
<[dispatcher:optDispatcherInputArg(), dispatcher.contracts:cDispatchContractOutputArg()];separator=",\n">
>>

componentCamkesDispatcherFn(dispatcher) ::= << 
void <componentCamkesDispatcherFnName(dispatcher)>(<componentCamkesDispatcherFnArgs(dispatcher)>) {
	<dispatcher.contracts:assignGlobals()>
	<dispatcher.externalHandlers:cUserDispatcher(dispatcher)>
}	


>>	 



assignGlobals(dispatchContract) ::= <<
<dispatchContract.port.globalMaxDispatchSize> = <dispatchContract.maxDispatchSize>;
<dispatchContract.port.globalIndex> = <dispatchContract.port.index>;
<if(dispatchContract.port.hasData)><dispatchContract.port.globalData> = *<dispatchContract.port.data>;<endif> 
*<dispatchContract.port.globalIndex> = 0;

>> 

copyToGlobalStmt(port) ::= <<
<if(port.type.isBaseType)><\\>
<port.globalDataSlot> = <port.name>;
<else><inputToValMemcpy(port.type, port.globalDataSlot, port.name)>
<endif>
>>

optConstInputArg(port) ::= "<if(port.hasData)>/* const */<port.nameAsInputParam><endif>"
optOutputArg(port) ::= "<if(port.hasData)><port.nameAsOutputParam><endif>"

componentSendFunction(port) ::= << 
bool <port.aadlWriterFnName>(<port:optConstInputArg()>) {
	if (*<port.globalIndex> \< <port.globalMaxDispatchSize>) {
		<if(port.hasData)><copyToGlobalStmt(port)><endif>
		(*<port.globalIndex>)++;
		return true;
	} else {
		return false;
	}
}

>>
  
copyToImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.readerWriterImplVar> = <port.name>;
<else><inputToValMemcpy(port.type, port.readerWriterImplVar, port.name)>
<endif>
>>

copyFromImplVarStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.readerWriterImplVar>;
<else><valToOutputMemcpy(port.type, port.name, port.readerWriterImplVar)>
<endif>
>>

drainDispatchers(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>
	

dispatcherDeclareData(dispatcherContract) ::= <<
<if(dispatcherContract.port.hasData)><dispatcherContract.dataDecl>;<endif>
<dispatcherContract.indexDecl>;

>>

passiveDispatcherCallOutPortArg(port) ::= <<
<if(port.hasData)><port.type.valToOutput><port.data>,<endif>
<port.type.valToOutput><port.index>
>>

writePassiveDispatcherArg(port) ::= <<
<if(port.hasData)><port.type.valToInput>(<port.data>[smaccm_it])<endif>
>>

passiveDispatcherCallOutArg(dispatchContract) ::= "<passiveDispatcherCallOutPortArg(dispatchContract.port)>"

callPassiveTargetDispatcher(portDest,portSrc) ::= <<
<portDest.threadImplementation.interfaceInstanceName>_<portDest.idlDispatcherName>(<writePassiveDispatcherArg(portSrc)>);	
>>

callActiveTargetDispatcher(portDest,portSrc) ::= <<
<portSrc.name>_<portDest.type.writerFn>(<writePassiveDispatcherArg(portSrc)>);	

>>

sendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:callPassiveTargetDispatcher(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:callActiveTargetDispatcher(dispatchContract.port)>
}

>>

dataDispatchFunctionName(dispatcher) ::= <<
<if(dispatcher.threadImplementation.isPassive)><\\>
<dispatcher.passiveComponentDispatcherPathName>
<else><componentCamkesDispatcherFnName(dispatcher)><endif>
>>

dataDispatchFunctionArgs(dispatcher) ::= <<
<if(dispatcher.hasData)><[dispatcher.name, dispatcher.contracts:passiveDispatcherCallOutArg() ];separator=", \n"> <else><\\>
		<dispatcher.contracts:passiveDispatcherCallOutArg();separator=", \n"> <endif>
>>

dataDispatchFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<if(dispatcher.hasData)><dispatcher.nameAsInputParam><endif>) {
	<dispatcher.contracts:dispatcherDeclareData()>
	
	// make the call: 
	<dataDispatchFunctionName(dispatcher)>(<dataDispatchFunctionArgs(dispatcher)>); 

<if(dispatcher.contracts)>
	// invoke any resulting `send' operations
	uint32_t smaccm_it; 
	<dispatcher.contracts:sendLoop(dispatcher)>
<endif>
}

>>



/*
<if(dispatcher.threadImplementation.isPassive)><\\>
	<dispatcher.passiveComponentDispatcherPathName>([<dispatcher.name>, {<dispatcher.contracts:passiveDispatcherCallOutArg()>}];separator=", ");
<else>
	<componentCamkesDispatcherFnName(dispatcher)>(<dispatcher.name> <dispatcher.contracts:passiveDispatcherCallOutArg()>);
<endif>
*/

///////////////////////////////////////////////////////////////////////////
//
// Functions for dispatching & main function
//
///////////////////////////////////////////////////////////////////////////

camkesRPCDispatchName(dispatcher) ::= <<
  <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>
>>

dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

bool <camkesRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
	return true;
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputName> arg) {
	// TODO: add mutex lock for queue here.
	<dispatcher.dispatchOccurredVar> = true;
	// TODO: add mutex unlock for queue here.
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>> 


// TODO: Dispatcher component for input events.
dispatcherComponentInputEventDecls(dispatcher) ::= <<

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.inputEventDispatcherPort.queueWriteName>(arg);
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>


dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// initialization routines ... skipped for now.
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatchers()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


///////////////////////////////////////////////////////////////////////////
//
// Putting it all together...
//
///////////////////////////////////////////////////////////////////////////

componentCFileDecls(threadImpl) ::= <<

#include <\u003C><threadImpl.componentGlueCodeHFileName><\u003E>
#include <\u003C><threadImpl.componentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<threadImpl.inputEventDataPortList:optInputEventDataPortDecls()>
<threadImpl.inputEventPortList:optInputEventPortDecls()>

<threadImpl.allOutputEventPorts:cPortTempVarDeclarations()>

///////////////////////////////////////////////////////////////////////////
//
// Functions for dispatching IRQs and Periodic Events
//
///////////////////////////////////////////////////////////////////////////
<threadImpl.dispatchers:dispatcherComponentEventDecls()>
<threadImpl.dispatchers:componentCamkesDispatcherFn()>
<threadImpl.allOutputEventPorts:componentSendFunction()>
<threadImpl.inputDataPortList:componentLocalReaderDecl()>
<threadImpl.outputDataPortList:componentRemoteWriterDecl()>

<if(threadImpl.isActive)><\\>
// Writing dispatchers...
<threadImpl.dispatchers:dataDispatchFunction()> 
<dispatcherComponentMainFunction(threadImpl)>
<endif>

>>

