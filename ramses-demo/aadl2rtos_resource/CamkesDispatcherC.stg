import "Common.stg"


////////////////////////////////////////////////////////////////////////////
//
// Declarations related to component dispatcher gluecode C files for CAmkES
// 
////////////////////////////////////////////////////////////////////////////

dispatcherComponentGlueCodeCFilePurpose(name) ::= <<
This C file contains the dispatcher functions for the 'active' thread 
<name>.  There is no direct interaction between the functionality in 
this file and user-level code.  Instead, this file interacts with the 
aadl-generated C file for passive components and the CAmkES generated
component skeleton.

This file contains: 
	1.) The main loop for the control thread to dispatch to 
		components
	2.) The dispatcher functions for all passive components.
	3.) The shared data for any of the active thread send/receive ports.
	4.) The receiver functions to store messages and wake up the 
		control thread.
	5.) The sender functions for other "active" components.

>>

dispatcherComponentGlueCodeCFilePrefix(name, date, path) ::= 
	"<stdFilePrefix(date, path, dispatcherComponentGlueCodeCFilePurpose(name))>"

dispatcherComponentGlueCodeCFilePostfix(name, path) ::= <<


<blockComment(arg={End of autogenerated file: <path>})>
>>

periodicDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.periodicTimeVar>);
}

>>

irqDispatcher(dispatcher) ::= <<
if (<dispatcher.dispatchOccurredVar>) {
	<dispatcher.dispatchOccurredVar> = false;
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDispatcher(dispatcher) ::= <<
while (!<dispatcher.isEmpty>) {
	// TODO: write decrement operation here!
	<dispatcher.dispatcherCFileDispatcherFnName>();
}

>>

eventDataDispatcher(dispatcher) ::= <<
while (!<dispatcher.inputEventDispatcherPort.isEmptyFnCall>) {
	<dispatcher.inputEventDispatcherPort.varDecl>;
	<dispatcher.inputEventDispatcherPort.queueReadName>(<dispatcher.type.inputToOutput><dispatcher.inputEventDispatcherPort.name>);
	<dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.inputEventDispatcherPort.name>); 
}

>>

drainDispatchers(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
<dispatcher:periodicDispatcher()>
<elseif(dispatcher.isIRQ)><\\>
<dispatcher:irqDispatcher()>
<elseif(dispatcher.isEvent)><\\>
<dispatcher:eventDispatcher()>
<elseif(dispatcher.isEventData)>
<dispatcher:eventDataDispatcher()>
<else>
	ERROR: dispatcher is not of periodic, IRQ, Event, or EventData type.
<endif>
>>
	

dispatcherDeclareData(dispatcherContract) ::= <<
<dispatcherContract.dataDecl>;
<dispatcherContract.indexDecl>;

>>

passiveDispatcherCallOutPortArg(port) ::= <<
<if(port.hasData)><port.type.valToOutput><port.data>,<endif>
<port.type.valToOutput><port.index>
>>

writePassiveDispatcherArg(port) ::= <<
<if(port.hasData)><port.type.valToInput>(<port.data>[smaccm_it])<endif>
>>

passiveDispatcherCallOutArg(dispatchContract) ::= <<, 
				<passiveDispatcherCallOutPortArg(dispatchContract.port)> >>

callPassiveTargetDispatcher(portDest,portSrc) ::= <<
<portDest.threadImplementation.interfaceInstanceName>_<portDest.idlDispatcherName>(<writePassiveDispatcherArg(portSrc)>);	
>>

callActiveTargetDispatcher(portDest,portSrc) ::= <<
<portSrc.name>_<portDest.type.writerFn>(<writePassiveDispatcherArg(portSrc)>);	

>>

sendLoop(dispatchContract,dispatcher) ::= <<
for (smaccm_it = 0; smaccm_it \< <dispatchContract.port.index>; smaccm_it++) {
   <dispatchContract.passiveDispatchTargetList:callPassiveTargetDispatcher(dispatchContract.port)>
   <dispatchContract.activeDispatchTargetList:callActiveTargetDispatcher(dispatchContract.port)>
}

>>

dispatcherComponentDataDispatchFunction(dispatcher) ::= <<
void <dispatcher.dispatcherCFileDispatcherFnName>(<dispatcher.nameAsInputParam>) {
	<dispatcher.contracts:dispatcherDeclareData()>
	
	// make the call: 
	<dispatcher.passiveComponentDispatcherPathName>(<dispatcher.name> <dispatcher.contracts:passiveDispatcherCallOutArg()>);
	
	<if(dispatcher.contracts)>
	// invoke any resulting `send' operations
	uint32_t smaccm_it; 
	<dispatcher.contracts:sendLoop(dispatcher)>
	<endif>
}


>>

dispatcherComponentReceiverQueueDecls(port) ::= <<
// Static variables for input receiver <port.name>
<port.queueDataDecl>;
<port.queueFrontDecl>;
<port.queueBackDecl>;
<port.queueFullDecl>;
>>

copyToQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.queueDataName>[<port.queueBackName>] = <port.name> ;
<else><inputToValMemcpy(port.type, {<port.queueDataName>[<port.queueBackName>]}, port.name )>
<endif>
>>

copyFromQueueDataStmt(port) ::= <<
<if(port.type.isBaseType)><port.type.outputToVal><port.name> = <port.queueDataName>[<port.queueBackName>] ;
<else><valToOutputMemcpy(port.type, port.name, {<port.queueDataName>[<port.queueBackName>]})>
<endif>
>>

dispatcherComponentInputEventDataPortDecls(port) ::= <<
<port.queueDataDecl>;
<port.queueFullDecl> = false;
<port.queueFrontDecl> = 0;
<port.queueBackDecl> = 0;

bool <port.queueIsFullName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (<port.queueFullName>);
}

bool <port.queueIsEmptyName>() {
	return (<port.queueFrontName> == <port.queueBackName>) && (!<port.queueFullName>); 
}

bool <port.queueReadName>(<port.nameAsOutputParam>) {
	if (<port.queueIsEmptyName>()) {
		return false;
	} else {
		<copyFromQueueDataStmt(port)>
		<port.queueBackName> = (<port.queueBackName> + 1) % <port.queueSize>; 
		<port.queueFullName> = false ; 
		return true;
	}
}

bool <port.queueWriteName>(const <port.nameAsInputParam>) {
	if (<port.queueIsFullName>()) {
		return false;
	} else {
		<copyToQueueDataStmt(port)>
		<port.queueFrontName> = (<port.queueFrontName> + 1) % <port.queueSize>; 		
		if (<port.queueBackName> == <port.queueFrontName>) { 
			<port.queueFullName> = true ; 
		}
		return true;
	}
}

void <port.name>_<port.type.writerFn>(<port.type.inputTypeName> arg) {
	// TODO: add mutex lock for queue here.
	<port.queueWriteName>(arg);
	// TODO: add mutex unlock for queue here.

	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
}

>>

dispatcherComponentInputEventPortDecls(port) ::= <<
<port.index> = 0;

bool <port.queueIsFullName>() {
	return false;
}

bool <port.queueIsEmptyName>() {
	return <port.index> == 0; 
}

void <port.name>_<port.type.writerFn>(<port.type.inputTypeName> arg) {
	// TODO: add mutex lock for queue here.
	<port.index>++;
	// TODO: add mutex unlock for queue here.

	<if(port.hasDispatcher)><port.threadImplementation.dispatcherUnlockStmt><endif>
}

>>

camkesRPCDispatchName(dispatcher) ::= <<
  <dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>
>>

dispatcherComponentPeriodicEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;
<dispatcher.type.name> <dispatcher.periodicTimeVar>;

void <camkesRPCDispatchName(dispatcher)><\\>
(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.dispatchOccurredVar> = true;
	<dispatcher.periodicTimeVar> = arg;
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentIRQEventDecls(dispatcher) ::= <<

bool <dispatcher.dispatchOccurredVar>;

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputName> arg) {
	// TODO: add mutex lock for queue here.
	<dispatcher.dispatchOccurredVar> = true;
	// TODO: add mutex unlock for queue here.
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>> 


// TODO: Dispatcher component for input events.
dispatcherComponentInputEventDecls(dispatcher) ::= <<

void <camkesRPCDispatchName(dispatcher)>(<dispatcher.type.inputTypeName> arg) {
	<dispatcher.inputEventDispatcherPort.queueWriteName>(arg);
	<dispatcher.threadImplementation.dispatcherUnlockStmt>
}

>>

dispatcherComponentEventDecls(dispatcher) ::=  <<

<if(dispatcher.isPeriodic)><dispatcherComponentPeriodicEventDecls(dispatcher)>
<elseif(dispatcher.isIRQ)><dispatcherComponentIRQEventDecls(dispatcher)>
<elseif(dispatcher.isInput)><else> ERROR: dispatcher is not IRQ, Event Data, or Periodic
<endif>
>>


dispatcherComponentMainFunction(threadImpl) ::= <<
int run() {
	// initialization routines ... skipped for now.
	
	// initial lock to await dispatch input.
	<threadImpl.dispatcherLockStmt>
	for(;;) {
		<threadImpl.dispatcherLockStmt>
		
		// drain the queues 
		<threadImpl.dispatchers:drainDispatchers()>
	}
	// won't ever get here, but form must be followed
	return 0;
}


>>


dispatcherComponentCDecls(model, threadImpl) ::= <<

#include <\u003C><threadImpl.model.systemTypeHeaderName><\u003E>
#include <\u003C><threadImpl.dispatcherComponentCamkesHFileName><\u003E>
#include <\u003C>string.h<\u003E>

<if(threadImpl.inputEventPortList)><\\>
// Functions for managing input event port queues and dispatchers
<endif>
<threadImpl.inputEventDataPortList:dispatcherComponentInputEventDataPortDecls()>
<threadImpl.inputEventPortList:dispatcherComponentInputEventPortDecls()>

// Functions for managing other input dispatchers 
<threadImpl.dispatchers:dispatcherComponentEventDecls()>

<threadImpl.dispatchers:dispatcherComponentDataDispatchFunction()>

<dispatcherComponentMainFunction(threadImpl)>

>>

