import "Common.stg"


////////////////////////////////////////////////////////////////////////////
//
// Declarations for periodic dispatcher gluecode c file
// 
////////////////////////////////////////////////////////////////////////////

periodicDispatcherCPurpose(componentName) ::= <<
This .c file contains the CAmkES periodic dispatcher component definition.
>>

periodicDispatcherCPrefix(name, date, path, datatypesHeader) ::= <<
<DARPALicenseComment()>

<filenameBlockComment(date, path, periodicDispatcherCPurpose(name))>

>>

writePeriodicDispatcher(dispatcher, threadCalendar) ::= <<
if ((smaccm_calendar_counter % (<dispatcher.periodicDispatcherPeriod> / smaccm_tick_interval)) == 0) {
	<dispatcher.dispatcherComponentDispatchName>_<dispatcher.type.writerFn>(smaccm_get_time_in_ms()); 
}
>>

periodicComponentCBody(threadCalendar) ::= <<

// Declarations for managing periodic thread dispatch
const uint32_t smaccm_tick_interval = <threadCalendar.greatestCommonDivisorInMilliseconds>;
const uint32_t smaccm_hyperperiod_subdivisions = <threadCalendar.hyperperiodSubdivisions>;
uint32_t smaccm_calendar_counter = 0;
uint32_t smaccm_calendar_ticks = 0;

// TODO: FIX This: we need to use some system function to return the current system time.
uint32_t smaccm_get_time_in_ms() {
  return (uint32_t)(smaccm_calendar_ticks * smaccm_tick_interval); 
}

void smaccm_thread_calendar() {
	<threadCalendar.periodicDispatchers:writePeriodicDispatcher(threadCalendar)>

	smaccm_calendar_counter = (smaccm_calendar_counter + 1) % smaccm_hyperperiod_subdivisions; 
	smaccm_calendar_ticks++; 
}

void smaccm_periodic_irq_callback() {
	epit_irq_callback();
	smaccm_thread_calendar(); 
	irq_reg_callback(smaccm_periodic_irq_callback, NULL);
}

int run(void)
{
	irq_reg_callback(smaccm_periodic_irq_callback, NULL);
	epit_init();
	epit_set_interval(<threadCalendar.greatestCommonDivisorInMilliseconds>);

	epit_start_timer();

	return 0;
}
 
>>

periodicDispatcherCPostfix(name, path) ::= <<

<blockComment(arg={End of autogenerated file: <path>})>

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for periodic dispatcher camkes component
// 
////////////////////////////////////////////////////////////////////////////

writePeriodicSender(dispatcher) ::= <<
<if(dispatcher.isPeriodic)><\\>
uses <dispatcher.type.readerWriterInterfaceName> <dispatcher.dispatcherComponentDispatchName>; 
<endif>
>>

writePeriodicSenders(threadImpl) ::= <<
<threadImpl.dispatchers:writePeriodicSender()>
>>
 
periodicDispatcherCamkesBody(model, type) ::= <<

import "../../interfaces/<type.readerWriterIdlFileName>";

component <model.threadCalendar.periodicDispatcherComponentName> {
	control;
	consumes DataAvailable irq;
	dataport Buf mem;
	<model.activeThreadImplementations:writePeriodicSenders()>
}

>>

////////////////////////////////////////////////////////////////////////////
//
// Declarations for camkes assembly
// 
////////////////////////////////////////////////////////////////////////////

camkesAssemblyPurpose(sysInstanceName) ::= <<
This header file contains the main CAmkES assembly for the  
AADL system instance rooted at <sysInstanceName>.
>>

camkesAssemblyPrefix(name, date, path) ::= "<stdFilePrefix(date, path, camkesAssemblyPurpose(name))>"

assemblyThreadImplementationImports(threadImpl) ::= <<
import "<threadImpl.rootToCamkesComponentFilePath>";
<if(threadImpl.isActive)><\\>
import "<threadImpl.rootToCamkesDispatcherComponentFilePath>";
<endif>
>>

assemblyThreadComponents(threadImpl) ::= <<
component <threadImpl.componentName> <threadImpl.componentInstanceName>;

>>

assemblyActiveThreadComponents(threadImpl) ::= <<
component <threadImpl.dispatcherComponentName> <threadImpl.dispatcherComponentInstanceName>;

>>

constructPeriodicComponent(calendar) ::= <<
<if(calendar.hasDispatchers)><\\>
component <calendar.periodicDispatcherComponentName> <calendar.periodicDispatcherInstanceName>;
<endif>
>>	

rpcConnection(cid, from1, from2, to1, to2) ::= 
   "connection seL4RPCCall <cid> (from <from1>.<from2>, to <to1>.<to2>);"

connectPassiveToActive(passiveThreadImpl, activeThreadImpl, model) ::= <<
<rpcConnection(model.generateConnectionName,
	activeThreadImpl.dispatcherComponentInstanceName,
	passiveThreadImpl.interfaceInstanceName,
	passiveThreadImpl.componentInstanceName,
	passiveThreadImpl.componentDispatcherInterfaceVarIdName)>

>>

assemblyConnectActiveToPassiveThreads(threadImpl, model) ::= <<
<model.passiveThreadImplementations:connectPassiveToActive(threadImpl, model)>
<rpcConnection(model.generateConnectionName, 
	threadImpl.dispatcherComponentInstanceName,
	threadImpl.interfaceInstanceName,
	threadImpl.componentInstanceName,
	threadImpl.componentDispatcherInterfaceVarIdName)>
	
>>


connectActiveSendToActiveSend(sourcePort, destPort, model) ::= <<
<if(destPort.threadImplementation.isActive)><\\>
<rpcConnection(model.generateConnectionName, 
	sourcePort.threadImplementation.dispatcherComponentInstanceName,
    sourcePort.name, 
	destPort.threadImplementation.dispatcherComponentInstanceName,
	destPort.name)> 
<endif>
>>

connectActiveToActive(connection, model) ::= <<
<connectActiveSendToActiveSend(connection.sourcePort, connection.destPort, model)>
>>

assemblyConnectActiveToActiveThreads(threadImpl, model) ::= <<
<threadImpl.isSrcOfConnectionList:connectActiveToActive(model)>
>>

connectActivePeriodic(dispatcher, threadImpl, model) ::= <<
<if(dispatcher.isPeriodic)><\\>
<rpcConnection(model.generateConnectionName, 
	model.threadCalendar.periodicDispatcherInstanceName,
	dispatcher.dispatcherComponentDispatchName, 
	threadImpl.dispatcherComponentInstanceName,
	dispatcher.dispatcherComponentDispatchName)>
<endif>
>>

assemblyConnectPeriodic(threadImpl, model) ::= <<
<threadImpl.dispatchers:connectActivePeriodic(threadImpl, model)>
>>

connectReaderWriter(connection, srcThreadImpl, model) ::= <<
<if(connection.sourcePort.isOutputDataPort)><\\>
<rpcConnection(model.generateConnectionName, 
	srcThreadImpl.componentInstanceName,
	connection.sourcePort.name,
	connection.destPortThreadImplementation.componentInstanceName,
	connection.destPort.name)>
<endif>
>>

assemblyConnectReadersWriters(threadImpl, model) ::= <<
<threadImpl.isSrcOfConnectionList:connectReaderWriter(threadImpl, model)>
>>

camkesAssemblyBody(model) ::= <<

import <\u003C>std_connector.camkes<\u003E>;
<if(model.threadCalendar.hasDispatchers)>import "<model.threadCalendar.periodicDispatcherPathName>";<endif>
<model.threadImplementations:assemblyThreadImplementationImports()>

component EPIT {
    hardware;
    dataport Buf mem;
    emits DataAvailable irq;
}

assembly {
	composition {
        component EPIT epit;
		<constructPeriodicComponent(model.threadCalendar)>
		
		// component instances for all AADL-defined threads
		<model.threadImplementations:assemblyThreadComponents()>
		
		// active thread components
		<model.activeThreadImplementations:assemblyActiveThreadComponents()>
	
		// connections from active dispatchers to passive threads
		<model.activeThreadImplementations:assemblyConnectActiveToPassiveThreads(model)>	
		
		// connections from active dispatcher send/receive to other active dispatcher send/receive
		<model.activeThreadImplementations:assemblyConnectActiveToActiveThreads(model)>
		
		// Periodic dispatcher connections
		<model.activeThreadImplementations:assemblyConnectPeriodic(model)>
        connection seL4HardwareMMIO epit_mem(from <model.threadCalendar.periodicDispatcherInstanceName>.mem, to epit.mem);
		connection seL4HardwareInterrupt irq(from epit.irq, to <model.threadCalendar.periodicDispatcherInstanceName>.irq);
		
		// Passive component read/write connections
		<model.threadImplementations:assemblyConnectReadersWriters(model)>
		
		// Shared data connections (currently unsupported: under development)
	}
    configuration {
		/* Freescale i.MX31 (KZM) */
        epit.mem_attributes = "0x53F98000:0x1000";
		epit.irq_attributes = 27;

		/* Freescale i.MX6 (Sabralite) */
        // epit.mem_attributes = "0x020D0000:0x1000";
		//epit.irq_attributes = 88;
    }
}

>>
