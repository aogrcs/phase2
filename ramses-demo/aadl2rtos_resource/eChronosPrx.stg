delimiters "$", "$"
import "xmlCommon.stg"


////////////////////////////////////////////////////////////////////////////
//
// Declarations related to eChronos .prx file
// 
////////////////////////////////////////////////////////////////////////////

prxPurpose(sysInstanceName) ::= <<
This file contains the main eChronos .prx assembly for the  
AADL system instance rooted at $sysInstanceName$.
>>

prxPrefix(name, date, path, datatypesHeader) ::= <<
<?xml version="1.0" encoding="UTF-8" ?>
$xmlDARPALicenseComment()$

$xmlFilenameBlockComment(date, path, prxPurpose(name))$

>>

prxPostfix(name, path) ::= <<

$xmlBlockComment(arg={End of autogenerated file: $path$})$

>>

writeTrampoline(name, flihName) ::= <<

	<trampoline>
		<name>$name$</name>
		<handler>$flihName$</handler>
	</trampoline>

>>

writeDispatcherTrampoline(dispatcher) ::= <<
$writeTrampoline(dispatcher.name, dispatcher.eChronosIrqSmaccmFlihName)$
>>

writeExternalIsrTrampoline(externalIsr) ::= <<
$writeTrampoline(externalIsr.name, externalIsr.handlerName)$
>>

writeTrampolines(model) ::= << 
$model.irqDispatchers:writeDispatcherTrampoline()$
$if(model.threadCalendar.hasDispatchers && 
	model.generateSystickIrq)$
$writeTrampoline("systick", model.threadCalendar.calendarFnName)$
$endif$
$model.externalISRs:writeExternalIsrTrampoline()$
>>

writeInterruptHandler(signalName) ::= <<
<$signalName$>rtos_internal_exception_preempt_trampoline_$signalName$</$signalName$>
>>

writeDispatcherInterruptHandler(dispatcher) ::= << 
	$writeInterruptHandler(dispatcher.name)$
>>


writeInterruptHandlers(model) ::= <<
	$writeInterruptHandler("systick")$
    $model.irqDispatchers:writeInterruptHandler()$
>>

writeSignalLabels(model) ::= <<
<!-- TBD: since each task will want to define its own signals, I'm not sure
     whether we want to define signal labels or not; I'm also not sure whether
     this is required by eChronos --> 
>>

writeTask(threadImpl) ::= <<
	<task>
		<name>$threadImpl.normalizedName$</name>
		<function>$threadImpl.threadImplMainFnName$</function>
		<priority>$threadImpl.priority$</priority>
		<stack_size>$threadImpl.stackSize$</stack_size>
	</task>
>>

writeTasks(model) ::= <<
$model.ActiveThreadImplementations:writeTask()$
$if(model.threadCalendar.hasDispatchers)$
	<!-- NOTE: the priority is not set correctly at this point; this will need to be revised -->
	<task>
		<name>smaccm_periodic_dispatcher</name>
		<function>smaccm_periodic_dispatcher</function>
		<priority>$model.threadCalendar.priority$</priority>
		<stack_size>512</stack_size>
	</task>
$else$
	<!-- No periodic dispatcher thread -->
$endif$
>>

writeMutex(name) ::= <<
  <mutex>
	<name>$name$</name>
  </mutex>
>>

// Fill in more stuff HERE!
writeInputPortMutex(port) ::= << 
	$writeMutex(port.mutex)$
>> 

writeActiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.eChronosThreadDispatcherMutex)$
$threadImpl.inputPortList:writeInputPortMutex()$
$threadImpl.externalMutexes:writeMutex()$
>>

writePassiveThreadMutexes(threadImpl) ::= <<
$writeMutex(threadImpl.eChronosThreadDispatcherMutex)$
$threadImpl.externalMutexes:writeMutex()$
>>

writeMutexes(model) ::= <<
$model.externalMutexList:writeMutex()$
$model.activeThreadImplementations:writeActiveThreadMutexes()$
$model.passiveThreadImplementations:writePassiveThreadMutexes()$
>>

writeSemaphore(name) ::= <<
  <semaphore>
    <name>$name$</name>
  </semaphore>
>>

writeThreadSemaphores(threadImpl) ::= <<
$threadImpl.externalSemaphores:writeSemaphore()$
>>

writeSemaphores(model) ::= <<
	$model.externalSemaphoreList:writeSemaphore()$
	$model.threadImplementations:writeThreadSemaphores()$
>>


writeInterruptEvent(name, taskName, signalSet) ::= <<
	<interrupt_event>
		<name>$name$</name>
		<task>$taskName$</task>
		<sig_set>$signalSet$</sig_set>
	</interrupt_event>
>>

writeExternalIrqEvent(externalIrqEvent) ::= <<
$writeInterruptEvent(
	externalIrqEvent.name, 
	externalIrqEvent.taskName,
	externalIrqEvent.signalSet)$
>>

writeActiveThreadIrqDispatcher(dispatcher) ::= << 
$if(dispatcher.isIRQ)$ 
$writeInterruptEvent(dispatcher.name, 
	dispatcher.threadImplementation.normalizedName,
	1)$
$endif$
>>

writeActiveThreadIrqDispatchers(threadImpl) ::= <<
$threadImpl.dispatchers:writeActiveThreadIrqDispatcher()$
>>

writeInterruptEvents(model) ::= <<
	$model.externalIRQEvents:writeExternalIrqEvent()$
	$model.activeThreadImplementations:writeActiveThreadIrqDispatchers()$
>>